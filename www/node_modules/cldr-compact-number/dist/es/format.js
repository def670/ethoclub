import { findLocaleData, needsFormatting, normalizeLocale, replaceNumber } from './format-utils';
import { extractIntPart, normalizeNumber } from './math-utils';
export function compactFormat(value, locale, localeData, options) {
    if (options === void 0) { options = {}; }
    var num = Number(value);
    if (!value || typeof num !== 'number') {
        return value;
    }
    // figure out which numbers hash based on the locale
    locale = normalizeLocale(locale); // en_GB -> en-GB
    var data = findLocaleData(localeData, locale);
    if (!data) {
        return value;
    }
    // take the absolute value and stash sign to apply at end
    var sign = 1;
    if (num < 0) {
        sign = -1;
        num = Math.abs(num);
    }
    // find specific rules: short or long
    var _a = options.financialFormat, financialFormat = _a === void 0 ? false : _a, _b = options.long, long = _b === void 0 ? false : _b, _c = options.significantDigits, significantDigits = _c === void 0 ? 0 : _c, _d = options.threshold, threshold = _d === void 0 ? 0.05 : _d;
    var rules = long ? data.decimal.long : data.decimal.short;
    if (!rules || num < 1000) {
        return value;
    }
    // 1. Take number and determine range it is in
    // 2. Extract specific rule from hash - ["0K", 1] meaning which value from the rule and number of zeros
    var matchingRule;
    var arbitraryPrecision = 0;
    for (var i = 0; i <= rules.length; i++) {
        if (num <= rules[i][0]) {
            var testRangeHigh = rules[i][0];
            // always use previous rule until within 5% threshold of upper limit
            if (!financialFormat && 1 - num / testRangeHigh > threshold) {
                // e.g use 950K instead of 1M
                // e.g use 101K instead of 0.1M
                matchingRule = rules[i - 1];
            }
            else {
                matchingRule = rules[i];
                if (!significantDigits || !financialFormat) {
                    // if we want to round up, we need to prevent numbers like 99,499 from rounding down to 99K
                    // /-private/math-utils will use this variable to round a number like 91 to 100 since we are within the threshold
                    arbitraryPrecision = 1;
                }
            }
            break;
        }
    }
    // 3. Normalise number by converting to decimal and cropping to number of digits
    //  1000 -> 1.000 -> 1K
    //  1600 -> 1.600 -> 2K
    // 4. Format according to formatter e.g. "0K"
    var range = matchingRule[0], opts = matchingRule[1];
    // cldr data is either `one` or `other`.  Defaulting to `one` for now
    var _e = opts.one || opts.other, formatter = _e[0], numberOfDigits = _e[1];
    if (!needsFormatting(formatter)) {
        return value;
    }
    var normalized = normalizeNumber(extractIntPart(num, range, numberOfDigits), arbitraryPrecision, sign, locale, options);
    return replaceNumber(normalized, formatter);
}
//# sourceMappingURL=format.js.map