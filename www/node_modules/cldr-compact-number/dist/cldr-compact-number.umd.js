(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.cldrCompactNumber = {}));
}(this, function (exports) { 'use strict';

    function replaceNumber(normalized, format) {
        // 1.734 -> 1K
        // replace 0's with absolute number while preserving space and remaining text
        // return format.replace(/0*(\s*)(\w+)/, Math.round(number) + '$1$2');
        return format.replace(/0*/, normalized);
    }
    function normalizeLocale(locale) {
        if (locale instanceof Array) {
            return locale[0].replace(/_/, '-').toLowerCase();
        }
        return locale.replace(/_/, '-').toLowerCase();
    }
    /**
     * If rule only contains 0, it indicates no short number formatting applied
     * e.g. "ja" 1234 -> 1234 and not 1K
     */
    function needsFormatting(format) {
        return format.match(/[^0]/);
    }
    /**
     * Given a format: { af: {locale: "af", numbers: {â€¦}} af-na: {locale: "af-NA", parentLocale: "af"} }
     * recursively find numbers hash
     *
     * @method findLocaleData
     * @param localeData
     * @param locale
     */
    function findLocaleData(localeData, locale) {
        var topLevelData = localeData[locale];
        if (!topLevelData) {
            return;
        }
        var numbersHash = topLevelData.numbers;
        var parentLocale = topLevelData.parentLocale;
        if (!numbersHash && parentLocale) {
            numbersHash = findLocaleData(localeData, parentLocale);
        }
        return numbersHash;
    }

    /**
     * Meant to either localize a number with toLocaleString or return an Integer
     * localization accepts 3 arguments
     *  - significantDigits
     *  - minimumFractionDigits
     *  - maximumFractionDigits
     */
    function normalizeNumber(decimal, arbitraryPrecision, sign, locale, _a) {
        var _b = _a.significantDigits, significantDigits = _b === void 0 ? 0 : _b, _c = _a.minimumFractionDigits, minimumFractionDigits = _c === void 0 ? 0 : _c, _d = _a.maximumFractionDigits, maximumFractionDigits = _d === void 0 ? 2 : _d;
        if (significantDigits) {
            return toLocaleFixed(toFixed(decimal, significantDigits), locale, {
                maximumFractionDigits: maximumFractionDigits,
                minimumFractionDigits: minimumFractionDigits
            });
        }
        return withRounding(decimal, arbitraryPrecision) * sign;
    }
    function extractIntPart(decimal, range, numberOfDigits) {
        // 1734 -> 1.734
        // 17345 -> 17.345
        // 999949 -> 999.9K with one significant digit or 999,9 mil in Spanish
        // this gives us the "int" (LHS) part of the number with the remains on the RHS
        return (decimal / range) * Math.pow(10, numberOfDigits - 1);
    }
    function toFixed(decimal, significantDigits) {
        // solves issues with toFixed returning a string
        // e.g. 999.94 -> 999.9
        // e.g. 999.95 -> 1000 instead of (999.95).toFixed(1) -> '1000.1'
        var powOf10 = Math.pow(10, significantDigits);
        return Math.round(decimal * powOf10) / powOf10;
    }
    function withRounding(decimal, arbitraryPrecision) {
        if (decimal <= 1) {
            // We do not want to round up to nearest 10 (Math.pow(10, 1)) when < 1.
            // Just round decimal
            return Math.round(decimal);
        }
        // rounding on floating point numbers
        // e.g. 99.5 -> 100
        var powOf10 = Math.pow(10, arbitraryPrecision);
        return Math.round(decimal / powOf10) * powOf10;
    }
    function toLocaleFixed(value, locale, digitsConfig) {
        if (value && typeof value === 'number') {
            return value.toLocaleString(locale, digitsConfig);
        }
    }

    function compactFormat(value, locale, localeData, options) {
        if (options === void 0) { options = {}; }
        var num = Number(value);
        if (!value || typeof num !== 'number') {
            return value;
        }
        // figure out which numbers hash based on the locale
        locale = normalizeLocale(locale); // en_GB -> en-GB
        var data = findLocaleData(localeData, locale);
        if (!data) {
            return value;
        }
        // take the absolute value and stash sign to apply at end
        var sign = 1;
        if (num < 0) {
            sign = -1;
            num = Math.abs(num);
        }
        // find specific rules: short or long
        var _a = options.financialFormat, financialFormat = _a === void 0 ? false : _a, _b = options.long, long = _b === void 0 ? false : _b, _c = options.significantDigits, significantDigits = _c === void 0 ? 0 : _c, _d = options.threshold, threshold = _d === void 0 ? 0.05 : _d;
        var rules = long ? data.decimal.long : data.decimal.short;
        if (!rules || num < 1000) {
            return value;
        }
        // 1. Take number and determine range it is in
        // 2. Extract specific rule from hash - ["0K", 1] meaning which value from the rule and number of zeros
        var matchingRule;
        var arbitraryPrecision = 0;
        for (var i = 0; i <= rules.length; i++) {
            if (num <= rules[i][0]) {
                var testRangeHigh = rules[i][0];
                // always use previous rule until within 5% threshold of upper limit
                if (!financialFormat && 1 - num / testRangeHigh > threshold) {
                    // e.g use 950K instead of 1M
                    // e.g use 101K instead of 0.1M
                    matchingRule = rules[i - 1];
                }
                else {
                    matchingRule = rules[i];
                    if (!significantDigits || !financialFormat) {
                        // if we want to round up, we need to prevent numbers like 99,499 from rounding down to 99K
                        // /-private/math-utils will use this variable to round a number like 91 to 100 since we are within the threshold
                        arbitraryPrecision = 1;
                    }
                }
                break;
            }
        }
        // 3. Normalise number by converting to decimal and cropping to number of digits
        //  1000 -> 1.000 -> 1K
        //  1600 -> 1.600 -> 2K
        // 4. Format according to formatter e.g. "0K"
        var range = matchingRule[0], opts = matchingRule[1];
        // cldr data is either `one` or `other`.  Defaulting to `one` for now
        var _e = opts.one || opts.other, formatter = _e[0], numberOfDigits = _e[1];
        if (!needsFormatting(formatter)) {
            return value;
        }
        var normalized = normalizeNumber(extractIntPart(num, range, numberOfDigits), arbitraryPrecision, sign, locale, options);
        return replaceNumber(normalized, formatter);
    }

    exports.default = compactFormat;
    exports.compactFormat = compactFormat;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
